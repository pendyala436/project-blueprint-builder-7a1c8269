/// <reference lib="webworker" />
import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
import { registerRoute, NavigationRoute } from 'workbox-routing';
import { NetworkFirst, CacheFirst, StaleWhileRevalidate, NetworkOnly } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';

declare let self: ServiceWorkerGlobalScope;

// ========================================
// UNIVERSAL PWA SERVICE WORKER
// Supports: All browsers, all devices, all OS
// ========================================

// App version for cache busting
const APP_VERSION = '1.0.0';
const CACHE_PREFIX = 'meowmeow-pwa';

// Clean up old caches
cleanupOutdatedCaches();

// Precache all assets generated by the build
precacheAndRoute(self.__WB_MANIFEST);

// ========================================
// CACHING STRATEGIES
// ========================================

// IMPORTANT (Dev/HMR safety): never cache Vite module URLs.
// If these get cached, dynamic imports can fail after updates and cause blank screens.
registerRoute(
  ({ url, request }) =>
    (request.destination === 'script' || request.destination === 'style') &&
    (url.pathname.startsWith('/src/') ||
      url.pathname.startsWith('/@') ||
      url.pathname.startsWith('/node_modules/')),
  new NetworkOnly()
);

// Cache API responses with NetworkFirst strategy
// Works across all browsers that support Service Workers
registerRoute(
  ({ url }) => 
    url.pathname.startsWith('/rest/') || 
    url.hostname.includes('supabase') ||
    url.hostname.includes('api'),
  new NetworkFirst({
    cacheName: `${CACHE_PREFIX}-api-${APP_VERSION}`,
    networkTimeoutSeconds: 10,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 60 * 60, // 1 hour
        purgeOnQuotaError: true,
      }),
    ],
  })
);

// Cache images with CacheFirst strategy
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: `${CACHE_PREFIX}-images-${APP_VERSION}`,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 200,
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
        purgeOnQuotaError: true,
      }),
    ],
  })
);

// Cache fonts with CacheFirst strategy (long-term caching)
registerRoute(
  ({ request }) => request.destination === 'font',
  new CacheFirst({
    cacheName: `${CACHE_PREFIX}-fonts-${APP_VERSION}`,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
        purgeOnQuotaError: true,
      }),
    ],
  })
);

// Cache static assets with StaleWhileRevalidate
registerRoute(
  ({ url, request }) =>
    (request.destination === 'script' || request.destination === 'style') &&
    // Limit to built assets only (prevents caching dev /src modules)
    url.pathname.startsWith('/assets/'),
  new StaleWhileRevalidate({
    cacheName: `${CACHE_PREFIX}-static-${APP_VERSION}`,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 60 * 60 * 24 * 7, // 7 days
        purgeOnQuotaError: true,
      }),
    ],
  })
);

// Cache audio/video with CacheFirst (for voice messages)
registerRoute(
  ({ request }) => 
    request.destination === 'audio' || 
    request.destination === 'video',
  new CacheFirst({
    cacheName: `${CACHE_PREFIX}-media-${APP_VERSION}`,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 60 * 24 * 7, // 7 days
        purgeOnQuotaError: true,
      }),
    ],
  })
);

// Cache Google Fonts with CacheFirst
registerRoute(
  ({ url }) => 
    url.origin === 'https://fonts.googleapis.com' ||
    url.origin === 'https://fonts.gstatic.com',
  new CacheFirst({
    cacheName: `${CACHE_PREFIX}-google-fonts-${APP_VERSION}`,
    plugins: [
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
      }),
    ],
  })
);

// ========================================
// PUSH NOTIFICATIONS
// Supported: Chrome, Firefox, Edge, Safari 16+, Samsung Internet, Opera
// ========================================

self.addEventListener('push', (event) => {
  if (!event.data) return;

  let data;
  try {
    data = event.data.json();
  } catch (e) {
    data = { title: 'Meow Meow', body: event.data.text() };
  }

  // Using type assertion to support vibrate and actions which are supported
  // in modern browsers but not in base TypeScript NotificationOptions
  const options = {
    body: data.body || 'New notification',
    icon: '/icons/icon-192x192.png',
    badge: '/icons/icon-72x72.png',
    data: {
      url: data.url || '/',
      dateOfArrival: Date.now(),
      image: data.image,
    },
    tag: data.tag || 'default',
    renotify: data.renotify || false,
    requireInteraction: data.requireInteraction || false,
    silent: data.silent || false,
  } as NotificationOptions;

  event.waitUntil(
    self.registration.showNotification(data.title || 'Meow Meow', options)
  );
});

// Handle notification clicks - works on all browsers
self.addEventListener('notificationclick', (event) => {
  event.notification.close();

  const action = event.action;
  const url = event.notification.data?.url || '/';

  if (action === 'dismiss') {
    return;
  }

  event.waitUntil(
    self.clients.matchAll({ type: 'window', includeUncontrolled: true }).then((clientList) => {
      // Try to focus an existing window
      for (const client of clientList) {
        if ('focus' in client) {
          return client.focus().then(() => {
            if ('navigate' in client) {
              return (client as WindowClient).navigate(url);
            }
          });
        }
      }
      // Open a new window if none exists
      if (self.clients.openWindow) {
        return self.clients.openWindow(url);
      }
    })
  );
});

// Handle notification close
self.addEventListener('notificationclose', (event) => {
  // Track notification dismissals if needed
  console.log('Notification closed:', event.notification.tag);
});

// ========================================
// BACKGROUND SYNC
// Supported: Chrome, Edge, Opera, Samsung Internet
// ========================================

self.addEventListener('sync', (event) => {
  switch (event.tag) {
    case 'sync-messages':
      event.waitUntil(syncMessages());
      break;
    case 'sync-offline-actions':
      event.waitUntil(syncOfflineActions());
      break;
    default:
      console.log('Unknown sync tag:', event.tag);
  }
});

async function syncMessages() {
  try {
    const cache = await caches.open(`${CACHE_PREFIX}-offline-messages`);
    const requests = await cache.keys();
    
    for (const request of requests) {
      try {
        const response = await cache.match(request);
        if (response) {
          const data = await response.json();
          await fetch(request, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data),
          });
          await cache.delete(request);
        }
      } catch (error) {
        console.error('Failed to sync message:', error);
      }
    }
  } catch (error) {
    console.error('Sync messages failed:', error);
  }
}

async function syncOfflineActions() {
  try {
    const cache = await caches.open(`${CACHE_PREFIX}-offline-actions`);
    const requests = await cache.keys();
    
    for (const request of requests) {
      try {
        const response = await cache.match(request);
        if (response) {
          const data = await response.json();
          await fetch(data.url, {
            method: data.method || 'POST',
            headers: data.headers || { 'Content-Type': 'application/json' },
            body: data.body ? JSON.stringify(data.body) : undefined,
          });
          await cache.delete(request);
        }
      } catch (error) {
        console.error('Failed to sync action:', error);
      }
    }
  } catch (error) {
    console.error('Sync offline actions failed:', error);
  }
}

// ========================================
// PERIODIC BACKGROUND SYNC
// Supported: Chrome 80+, Edge 80+
// ========================================

self.addEventListener('periodicsync', (event: any) => {
  switch (event.tag) {
    case 'check-notifications':
      event.waitUntil(checkForNotifications());
      break;
    case 'update-content':
      event.waitUntil(updateCachedContent());
      break;
  }
});

async function checkForNotifications() {
  // Placeholder for checking new notifications
  console.log('Checking for new notifications...');
}

async function updateCachedContent() {
  // Update cached content in the background
  console.log('Updating cached content...');
}

// ========================================
// SHARE TARGET HANDLER
// Supported: Chrome, Edge, Samsung Internet
// ========================================

self.addEventListener('fetch', (event) => {
  const url = new URL(event.request.url);
  
  // Handle share target
  if (url.pathname === '/share-target' && event.request.method === 'POST') {
    event.respondWith(handleShareTarget(event.request));
    return;
  }
});

async function handleShareTarget(request: Request): Promise<Response> {
  try {
    const formData = await request.formData();
    const title = formData.get('title');
    const text = formData.get('text');
    const url = formData.get('url');
    const files = formData.getAll('media');

    // Store shared data for the app to pick up
    const cache = await caches.open(`${CACHE_PREFIX}-share-target`);
    await cache.put('/share-data', new Response(JSON.stringify({
      title,
      text,
      url,
      hasFiles: files.length > 0,
      timestamp: Date.now(),
    })));

    // Redirect to the app
    return Response.redirect('/?shared=true', 303);
  } catch (error) {
    console.error('Share target error:', error);
    return Response.redirect('/', 303);
  }
}

// ========================================
// SERVICE WORKER LIFECYCLE
// ========================================

// Skip waiting and claim clients immediately
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
  
  // Handle cache clear request
  if (event.data && event.data.type === 'CLEAR_CACHE') {
    event.waitUntil(clearAllCaches());
  }
  
  // Handle get cache size request
  if (event.data && event.data.type === 'GET_CACHE_SIZE') {
    event.waitUntil(getCacheSize().then(size => {
      event.ports[0]?.postMessage({ size });
    }));
  }
});

self.addEventListener('activate', (event) => {
  event.waitUntil(
    Promise.all([
      self.clients.claim(),
      // Clean up old versioned caches
      caches.keys().then(cacheNames => {
        return Promise.all(
          cacheNames
            .filter(name => name.startsWith(CACHE_PREFIX) && !name.includes(APP_VERSION))
            .map(name => caches.delete(name))
        );
      }),
    ])
  );
});

self.addEventListener('install', (event) => {
  // Force the waiting service worker to become the active one
  self.skipWaiting();
});

// ========================================
// UTILITY FUNCTIONS
// ========================================

async function clearAllCaches(): Promise<void> {
  const cacheNames = await caches.keys();
  await Promise.all(
    cacheNames
      .filter(name => name.startsWith(CACHE_PREFIX))
      .map(name => caches.delete(name))
  );
}

async function getCacheSize(): Promise<number> {
  if ('storage' in navigator && 'estimate' in navigator.storage) {
    const estimate = await navigator.storage.estimate();
    return estimate.usage || 0;
  }
  return 0;
}

// ========================================
// OFFLINE FALLBACK
// ========================================

// This is handled by workbox precaching, but we add a fallback
self.addEventListener('fetch', (event) => {
  // Only handle navigation requests that fail
  if (event.request.mode === 'navigate') {
    event.respondWith(
      fetch(event.request).catch(() => {
        return caches.match('/') || new Response('Offline', {
          status: 503,
          statusText: 'Service Unavailable',
        });
      })
    );
  }
});